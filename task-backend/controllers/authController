const User = require("../models/User");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const Task = require("../models/Task");
const crypto = require("crypto");
const { sendResetEmail, sendVerificationEmail } = require("../utils/sendEmail");
const VerificationToken = require("../models/VerificationToken");

exports.register = async (req, res) => {
  try {
    const { email, password, recaptchaToken } = req.body;

    if (process.env.NODE_ENV !== "test") {
      const response = await fetch(
        `https://www.google.com/recaptcha/api/siteverify?secret=${process.env.RECAPTCHA_SECRET_KEY}&response=${recaptchaToken}`,
        { method: "POST" }
      );
      const data = await response.json();
      if (!data.success) {
        return res
          .status(400)
          .json({ error: "La verificación de reCAPTCHA falló." });
      }
    }

    const existing = await User.findOne({ email });
    if (existing) {
      return res.status(400).json({ error: "El email ya está registrado." });
    }

    const hashed = await bcrypt.hash(password, 10);
    const user = new User({ email, password: hashed });
    await user.save();

    res.status(201).json({ message: "Usuario registrado correctamente." });
  } catch (err) {
    console.error("❌ Error en registro:", err);
    res.status(500).json({ error: "Error al registrar usuario." });
  }
};

exports.register = async (req, res) => {
  try {
    const { email, password, recaptchaToken, name } = req.body;
    if (!email || !password) {
      return res
        .status(400)
        .json({ error: "Email y contraseña son requeridos." });
    }

    const exists = await User.findOne({ email });
    if (exists) {
      if (!exists.emailVerified) {
        // Usuario ya creado pero no verificado: ofrecer reenviar verificación
        return res.status(409).json({
          error:
            "Este correo ya está registrado pero no verificado. Reenvía el correo de verificación.",
          code: "UNVERIFIED",
        });
      }
      return res
        .status(400)
        .json({ error: "Ya existe una cuenta con ese correo." });
    }
    const hashed = await bcrypt.hash(password, 10);
    const user = await User.create({
      email,
      password: hashed,
      emailVerified: false,
    });

    const raw = crypto.randomBytes(32).toString("hex");
    const tokenHash = crypto.createHash("sha256").update(raw).digest("hex");
    const expiresAt = new Date(Date.now() + 60 * 60 * 1000);
    await VerificationToken.create({ userId: user._id, tokenHash, expiresAt });

    const base =
      process.env.APP_BASE_URL || `${req.protocol}://${req.get("host")}`;
    const verifyUrl = `${base}/api/auth/verify-email?token=${raw}`;
    // Envío con rollback si falla
    try {
      await sendVerificationEmail(user.email, verifyUrl);
    } catch (e) {
      console.error(
        "⚠️  No se pudo enviar el correo de verificación:",
        e.message
      );
      await VerificationToken.deleteMany({ userId: user._id }).catch(() => {});
      await User.findByIdAndDelete(user._id).catch(() => {});
      return res.status(502).json({
        error:
          "No se pudo enviar el correo de verificación. Intenta nuevamente en unos minutos.",
      });
    }
    const payload = {
      message: "Usuario creado. Revisa tu correo para confirmar tu email.",
    };
    if (process.env.NODE_ENV !== "production") payload.devVerifyUrl = verifyUrl;
    return res.status(201).json(payload);
  } catch (err) {
    console.error("register error:", err);
    return res.status(500).json({ error: "Error al registrar usuario." });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password)
      return res
        .status(400)
        .json({ error: "Email y contraseña son requeridos." });
    const user = await User.findOne({ email });
    if (!user)
      return res.status(400).json({ error: "Credenciales inválidas." });
    if (!user.emailVerified)
      return res
        .status(403)
        .json({ error: "Debes verificar tu correo antes de iniciar sesión." });
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch)
      return res.status(400).json({ error: "Credenciales inválidas." });
    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, {
      expiresIn: "7d",
    });
    return res.json({ token });
  } catch (err) {
    console.error("❌ Error en login:", err);
    return res.status(500).json({ error: "Error al iniciar sesión." });
  }
};

exports.verifyEmail = async (req, res) => {
  try {
    const { token } = req.query;
    if (!token) return res.status(400).send("Missing token");
    const tokenHash = crypto.createHash("sha256").update(token).digest("hex");
    const record = await VerificationToken.findOne({ tokenHash });
    const errorRedirect = (msg) => {
      console.warn("verifyEmail:", msg);
      const url = process.env.FRONTEND_URL
        ? `${process.env.FRONTEND_URL}/verify/error`
        : "/verify/error";
      return res.redirect(302, url);
    };
    if (!record) return errorRedirect("no record / invalid token");
    if (record.usedAt) return errorRedirect("token already used");
    if (record.expiresAt < new Date()) return errorRedirect("token expired");
    await User.findByIdAndUpdate(record.userId, { emailVerified: true });
    record.usedAt = new Date();
    await record.save();
    const redirect = process.env.FRONTEND_URL
      ? `${process.env.FRONTEND_URL}/verify/success`
      : "/";
    return res.redirect(302, redirect);
  } catch (err) {
    console.error("❌ verifyEmail error:", err);
    const url = process.env.FRONTEND_URL
      ? `${process.env.FRONTEND_URL}/verify/error`
      : "/verify/error";
    return res.redirect(302, url);
  }
};

exports.resendVerification = async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ error: "Email requerido" });
    const user = await User.findOne({ email });
    if (!user)
      return res.json({
        message: "Si el correo existe, se envió un nuevo enlace.",
      });
    if (user.emailVerified)
      return res.json({ message: "El correo ya está verificado." });
    await VerificationToken.deleteMany({ userId: user._id });
    const raw = crypto.randomBytes(32).toString("hex");
    const tokenHash = crypto.createHash("sha256").update(raw).digest("hex");
    const expiresAt = new Date(Date.now() + 60 * 60 * 1000);
    await VerificationToken.create({ userId: user._id, tokenHash, expiresAt });
    const base =
      process.env.APP_BASE_URL || `${req.protocol}://${req.get("host")}`;
    const verifyUrl = `${base}/api/auth/verify-email?token=${raw}`;
    await sendVerificationEmail(user.email, verifyUrl);
    return res.json({
      message: "Si el correo existe, se envió un nuevo enlace.",
    });
  } catch (err) {
    console.error("❌ resendVerification error:", err);
    return res.status(500).json({ error: "Error al reenviar verificación." });
  }
};

exports.getProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    if (!user) {
      return res.status(404).json({ error: "Usuario no encontrado." });
    }
    res.json({ email: user.email });
  } catch (err) {
    console.error("❌ Error al obtener perfil:", err);
    res.status(500).json({ error: "Error al obtener perfil." });
  }
};

exports.deleteAccount = async (req, res) => {
  try {
    const { password, confirmText } = req.body;

    if (confirmText !== "QUIERO ELIMINAR MI CUENTA") {
      return res.status(400).json({ error: "La confirmación no coincide." });
    }

    const user = await User.findById(req.user.userId);
    if (!user) {
      return res.status(404).json({ error: "Usuario no encontrado." });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ error: "Contraseña incorrecta." });
    }

    // Eliminar todas las tareas del usuario
    await Task.deleteMany({ user: req.user.userId });

    // Eliminar usuario
    await User.findByIdAndDelete(req.user.userId);

    res.json({ message: "Cuenta y datos eliminados correctamente." });
  } catch (err) {
    console.error("❌ Error al borrar cuenta:", err);
    res.status(500).json({ error: "Error al eliminar cuenta." });
  }
};

exports.requestReset = async (req, res) => {
  const { email } = req.body;
  const user = await User.findOne({ email });
  if (!user) {
    return res
      .status(400)
      .json({ error: "No existe ninguna cuenta con ese correo." });
  }

  const token = crypto.randomBytes(20).toString("hex");
  user.resetPasswordToken = token;
  user.resetPasswordExpires = Date.now() + 3600000; // 1 hora
  await user.save();

  const resetLink = `${process.env.FRONTEND_URL}/reset-password/${token}`;
  await sendResetEmail(email, resetLink);

  res.json({ message: "Hemos enviado un enlace de recuperación a tu correo." });
};

exports.resetPassword = async (req, res) => {
  const { token, newPassword } = req.body;
  const user = await User.findOne({
    resetPasswordToken: token,
    resetPasswordExpires: { $gt: Date.now() },
  });

  if (!user) {
    return res
      .status(400)
      .json({ error: "El token no es válido o ha expirado." });
  }

  const hashed = await bcrypt.hash(newPassword, 10);
  user.password = hashed;
  user.resetPasswordToken = undefined;
  user.resetPasswordExpires = undefined;
  await user.save();

  res.json({ message: "Contraseña actualizada correctamente." });
};
